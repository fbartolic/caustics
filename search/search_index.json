{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00a4 caustics is a code for computing microlensing light curves of single, binary, and triple lens systems using the contour integration method. It is built using the JAX library which enables the computation of exact gradients of the code outputs with respect to all input parameters through the use of automatic differentiation . It has the following feautures: Fast (miliseconds) and accurate computation of binary and triple lens microlensing light curves for extended limb-darkened sources. Automatic differentiation enables the use of gradient-based inference methods such as Hamiltonian Monte Carlo when fitting multiple lens microlensing light curves. A differentiable JAX version of a complex polynomial root solver CompEA which uses the Aberth-Ehrlich method to obtain all roots of a complex polynomial at once using an implicit deflation strategy. The gradient of the solutions with respect to the polynomial coefficients is obtained through implicit differentiation . Hexadecapole approximation from Cassan 2017 is used to substantially speed up the computation of the magnification everywhere except near the caustics. Installation \u00a4 caustics is still being actively developed and is not yet released on PyPI. To install the development version, clone this repository, create a new conda environment, cd into the repository and run conda env update -- file environment . yml && pip install . caustics does not currently support Apple M1 processors except via Rosetta emulation. To install it open the terminal through Rosetta and the command from above. References \u00a4 caustics paper coming soon! Light-curve calculations for triple microlensing systems On a compensated Ehrlich-Aberth method for the accurate computation of all polynomial roots A robust and efficient method for calculating the magnification of extended sources caused by gravitational lenses VBBINARYLENSING: a public package for microlensing light-curve computation Fast computation of quadrupole and hexadecapole approximations in microlensing with a single point-source evaluation","title":"Home"},{"location":"#overview","text":"caustics is a code for computing microlensing light curves of single, binary, and triple lens systems using the contour integration method. It is built using the JAX library which enables the computation of exact gradients of the code outputs with respect to all input parameters through the use of automatic differentiation . It has the following feautures: Fast (miliseconds) and accurate computation of binary and triple lens microlensing light curves for extended limb-darkened sources. Automatic differentiation enables the use of gradient-based inference methods such as Hamiltonian Monte Carlo when fitting multiple lens microlensing light curves. A differentiable JAX version of a complex polynomial root solver CompEA which uses the Aberth-Ehrlich method to obtain all roots of a complex polynomial at once using an implicit deflation strategy. The gradient of the solutions with respect to the polynomial coefficients is obtained through implicit differentiation . Hexadecapole approximation from Cassan 2017 is used to substantially speed up the computation of the magnification everywhere except near the caustics.","title":"Overview"},{"location":"#installation","text":"caustics is still being actively developed and is not yet released on PyPI. To install the development version, clone this repository, create a new conda environment, cd into the repository and run conda env update -- file environment . yml && pip install . caustics does not currently support Apple M1 processors except via Rosetta emulation. To install it open the terminal through Rosetta and the command from above.","title":"Installation"},{"location":"#references","text":"caustics paper coming soon! Light-curve calculations for triple microlensing systems On a compensated Ehrlich-Aberth method for the accurate computation of all polynomial roots A robust and efficient method for calculating the magnification of extended sources caused by gravitational lenses VBBINARYLENSING: a public package for microlensing light-curve computation Fast computation of quadrupole and hexadecapole approximations in microlensing with a single point-source evaluation","title":"References"},{"location":"api/extended_source/","text":"Extended source \u00a4 caustics.extended_source \u00a4 Compute the magnification of an extended source using contour integration. mag_extended_source ( w0 , rho , nlenses = 2 , npts_limb = 150 , limb_darkening = False , u1 = 0.0 , npts_ld = 100 , roots_itmax = 2500 , roots_compensated = False , ** params ) \u00a4 Compute the magnification of an extended source with radius rho for a system with nlenses lenses. If nlenses is 2 (binary lens) or 3 (triple lens), the coordinate system is set up such that the the origin is at the center of mass of the first two lenses which are both located on the real line. The location of the first lens is -sq/(1 + q) and the second lens is at s/(1 + q). The optional third lens is located at an arbitrary position in the complex plane r3 e^(-i psi). The magnification is computed using contour integration in the image plane. Boolean flag limb_darkening indicated whether linear limb-darkening needs to taken into account. If limb_darkening is set to True the linear limb-darkening coefficient u1 needs to be specified as well. Note that turning on this flag slows down the computation by up to an order of magnitude. Parameters: Name Type Description Default w0 complex Source position in the complex plane. required rho float Source radius in Einstein radii. required npts_limb int Initial number of points uniformly distributed on the source limb when computing the point source magnification. The final number of points is greater than this value because the number of points is decreased geometrically by a factor of 1/2 until it reaches 2. 150 limb_darkening bool If True, compute the magnification of a limb-darkened source. If limb_darkening is enabled the u1 linear limb-darkening coefficient needs to be specified. Defaults to False. False u1 float Linear limb darkening coefficient. Defaults to 0.. 0.0 npts_ld int Number of points at which the stellar brightness function is evaluated when computing the integrals P and Q from Dominik 1998. Defaults to 100. 100 **s float Separation between the two lenses. The first lens is located at -sq/(1 + q) and the second lens is at s/(1 + q) on the real line. required **q float Mass ratio defined as m2/m1. required **q3 float Mass ratio defined as m3/m1. required **r3 float Magnitude of the complex position of the third lens. required **psi float Phase angle of the complex position of the third lens. required **roots_itmax int Number of iterations for the root solver. required **roots_compensated bool Whether to use the compensated arithmetic version of the Ehrlich-Aberth root solver. required Returns: Name Type Description float Total magnification.","title":"Extended source"},{"location":"api/extended_source/#extended-source","text":"","title":"Extended source"},{"location":"api/extended_source/#caustics.extended_source","text":"Compute the magnification of an extended source using contour integration.","title":"extended_source"},{"location":"api/lightcurve/","text":"Lightcurve \u00a4 caustics.lightcurve \u00a4 Function for computing the magnification of an extended source at an arbitrary set of points in the source plane. mag ( w_points , rho , nlenses = 2 , npts_limb = 200 , limb_darkening = False , u1 = 0.0 , npts_ld = 100 , roots_itmax = 2500 , roots_compensated = False , ** params ) \u00a4 Compute the magnification for a system with nlenses and an extended limb-darkned source at a set of complex points w_points in the source plane. This function calls either mag_hexadecapole or mag_extended_source for each point in w_points depending on whether or not the hexadecapole approximation is good enough. If nlenses is 2 (binary lens) or 3 (triple lens), the coordinate system is set such that the first two lenses with mass fractions $e1=m_1/m_\\mathrm{total}$ and $e2=m_2/m_\\mathrm{total}$ are positioned on the x-axis at locations \\(r_1=a\\) and \\(r_2=-a\\) respectively. The third lens is at an arbitrary position in the complex plane \\(r_3\\) . For a single lens lens the magnification is computed analytically. For binary and triple lenses computing the magnification involves solving for the roots of a complex polynomial with degree ( nlenses **2 + 1) using the Elrich-Aberth algorithm. Optional keywords itmax and compensated can be passed to the root solver as a dictionary. itmax is the number of root solver iterations, it defaults to 2500 , and compensated specifies whether the root solver should use the compensated version of or the Elrich-Aberth algorithm or the regular version, it defaults to False . Parameters: Name Type Description Default w_points array_like Source positions in the complex plane. required rho float Source radius in Einstein radii. required npts_limb int Initial number of points uniformly distributed on the source limb when computing the point source magnification. The final number of points is greater than this value because the number of points is decreased geometrically by a factor of 1/2 until it reaches 2. 200 limb_darkening bool If True, compute the magnification of a limb-darkened source. If limb_darkening is enabled the u1 linear limb-darkening coefficient needs to be specified. Defaults to False. False u1 float Linear limb darkening coefficient. Defaults to 0.. 0.0 npts_ld int Number of points at which the stellar brightness function is evaluated when computing the integrals P and Q from Dominik 1998. Defaults to 50. 100 **s float Separation between the two lenses. The first lens is located at -sq/(1 + q) and the second lens is at s/(1 + q) on the real line. required **q float Mass ratio defined as m2/m1. required **q3 float Mass ratio defined as m3/m1. required **r3 float Magnitude of the complex position of the third lens. required **psi float Phase angle of the complex position of the third lens. required **roots_itmax int Number of iterations for the root solver. required **roots_compensated bool Whether to use the compensated arithmetic version of the Ehrlich-Aberth root solver. required Returns: Name Type Description array_like Magnification array.","title":"Lightcurve"},{"location":"api/lightcurve/#lightcurve","text":"","title":"Lightcurve"},{"location":"api/lightcurve/#caustics.lightcurve","text":"Function for computing the magnification of an extended source at an arbitrary set of points in the source plane.","title":"lightcurve"},{"location":"api/point_source/","text":"Point source \u00a4 caustics.point_source \u00a4 mag_point_source ( w , nlenses = 2 , roots_itmax = 2500 , roots_compensated = False , ** params ) \u00a4 Compute the magnification of a point source for a system with nlenses lenses. If nlenses is 2 (binary lens) or 3 (triple lens), the coordinate system is set up such that the the origin is at the center of mass of the first two lenses which are both located on the real line. The location of the first lens is -sq/(1 + q) and the second lens is at s/(1 + q). The optional third lens is located at an arbitrary position in the complex plane r3 e^(-i psi). For a single lens lens the magnification is computed analytically. For binary and triple lenses computing the magnification involves solving for the roots of a complex polynomial with degree ( nlenses **2 + 1) using the Elrich-Aberth algorithm. Parameters: Name Type Description Default w array_like Source position in the complex plane. required **s float Separation between the two lenses. The first lens is located at -sq/(1 + q) and the second lens is at s/(1 + q) on the real line. required **q float Mass ratio defined as m2/m1. required **q3 float Mass ratio defined as m3/m1. required **r3 float Magnitude of the complex position of the third lens. required **psi float Phase angle of the complex position of the third lens. required **roots_itmax int Number of iterations for the root solver. required **roots_compensated bool Whether to use the compensated arithmetic version of the Ehrlich-Aberth root solver. required Returns: Name Type Description array_like The point source magnification evaluated at w. critical_and_caustic_curves ( npts = 200 , nlenses = 2 , ** params ) \u00a4","title":"Point source"},{"location":"api/point_source/#point-source","text":"","title":"Point source"},{"location":"api/point_source/#caustics.point_source","text":"","title":"point_source"}]}